<script>
  (function () {
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    async function createScene() {
      const scene = new BABYLON.Scene(engine);

      scene.createDefaultCameraOrLight(true, true, true);
      scene.createDefaultEnvironment({ createGround: false, environmentTexture: false });

      // Invisible ground for desktop picking
      const pickGround = BABYLON.MeshBuilder.CreateGround("pickGround", { width: 100, height: 100 }, scene);
      pickGround.isPickable = true;
      pickGround.isVisible = false;
      pickGround.position.y = 0;

      const xr = await scene.createDefaultXRExperienceAsync({
        uiOptions: { sessionMode: "immersive-ar" },
        optionalFeatures: true
      });

      const fm = xr.baseExperience.featuresManager;
      const hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
        entityTypes: ["plane", "mesh"],
        offsetRay: new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 1), 20)
      });

      let lastHitPose = null;
      hitTest.onHitTestResultObservable.add(results => {
        if (results && results.length) lastHitPose = results[0].transformationMatrix.clone();
      });

      const ROOT = "./";
      const FILE = "blue_crab.glb";

      let originalRoot = null;
      try {
        const { meshes } = await BABYLON.SceneLoader.ImportMeshAsync("", ROOT, FILE, scene);
        originalRoot = meshes.find(m => !m.parent) || meshes[0];
        meshes.forEach(m => m.setEnabled(false));
        const bb0 = originalRoot.getHierarchyBoundingVectors();
        const size = bb0.max.subtract(bb0.min);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = maxDim > 0 ? 0.35 / maxDim : 1.0;
        originalRoot.scaling.scaleInPlace(scale);
        originalRoot.computeWorldMatrix(true);
      } catch (e) {
        console.error("Failed to load blue_crab.glb. Ensure it is in the same folder and not an LFS pointer.", e);
      }

      let placedRoot = null;
      function ensurePlacedRoot() {
        if (!originalRoot) return null;
        if (!placedRoot) {
          placedRoot = originalRoot.clone("placedRoot");
          placedRoot.getChildMeshes(true).forEach(m => m.setEnabled(true));
          placedRoot.setEnabled(true);
        }
        return placedRoot;
      }

      function dropToPlaneY0(mesh) {
        const bb = mesh.getHierarchyBoundingVectors(true);
        const minY = bb.min.y;
        if (isFinite(minY)) mesh.position.y -= minY;
        mesh.computeWorldMatrix(true);
      }

      function placeAtHit() {
        if (!originalRoot || !lastHitPose) return;
        const m = ensurePlacedRoot();
        if (!m) return;
        m.setPreTransformMatrix(lastHitPose);
        dropToPlaneY0(m);
      }

      function placeAtPosition(pos) {
        if (!originalRoot || !pos) return;
        const m = ensurePlacedRoot();
        if (!m) return;
        m.setAbsolutePosition(pos.clone());
        dropToPlaneY0(m);
      }

      // Tap in AR
      xr.baseExperience.sessionManager.onSelectObservable.add(() => placeAtHit());

      // Right controller: trigger & thumbstick
      xr.input.onControllerAddedObservable.add(xrController => {
        if (xrController.inputSource.handedness !== "right") return;
        xrController.onMotionControllerInitObservable.add(mc => {
          const trigger = mc.getComponentOfType("trigger");
          trigger.onButtonStateChangedObservable.add(() => { if (trigger.pressed) placeAtHit(); });

          const stick = mc.getComponentOfType("xr-standard-thumbstick");
          const speed = 0.0025;
          scene.onBeforeRenderObservable.add(() => {
            if (!placedRoot || !stick || !stick.axes) return;
            const dx = stick.axes.x || 0;
            const dy = stick.axes.y || 0;
            if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) return;
            const dt = engine.getDeltaTime();
            const pos = placedRoot.getAbsolutePosition().clone();
            pos.x += dx * speed * dt;
            pos.z += dy * speed * dt;
            placedRoot.setAbsolutePosition(pos);
          });
        });
      });

      // Mouse/touch outside AR: click to place
      scene.onPointerDown = function () {
        const inXR = xr.baseExperience && xr.baseExperience.state === BABYLON.WebXRState.IN_XR;
        if (inXR) {
          placeAtHit();
          return;
        }
        const pick = scene.pick(scene.pointerX, scene.pointerY);
        if (pick && pick.hit && pick.pickedPoint) {
          placeAtPosition(pick.pickedPoint);
        } else if (scene.activeCamera) {
          // Fallback: intersect y=0 plane
          const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), scene.activeCamera);
          if (ray && Math.abs(ray.direction.y) > 1e-6) {
            const t = -ray.origin.y / ray.direction.y;
            if (t > 0) placeAtPosition(ray.origin.add(ray.direction.scale(t)));
          }
        }
      };

      return scene;
    }

    createScene().then(scene => {
      engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener("resize", () => engine.resize());
  })();
</script>
