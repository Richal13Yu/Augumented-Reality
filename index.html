<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(canvas, true);
            camera.inputs.removeByType("FreeCameraGamepadInput");
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;
        
            var GLB_URL = "./blue_crab.glb";
            var container = null;
            BABYLON.SceneLoader.LoadAssetContainer("", GLB_URL, scene, function (c) { container = c; });
        
            var marker = BABYLON.MeshBuilder.CreateTorus("marker", { diameter: 0.6, thickness: 0.08 }, scene);
            marker.rotationQuaternion = new BABYLON.Quaternion();
            marker.isVisible = false;
        
            scene.createDefaultXRExperienceAsync({
                uiOptions: { sessionMode: "immersive-ar" },
                inputOptions: { doNotLoadControllerMeshes: true },
                optionalFeatures: true
            }).then((xr) => {
                const fm = xr.baseExperience.featuresManager;
                const hitTest = fm.enableFeature(BABYLON.WebXRHitTest.Name, "latest");
                const anchors = fm.enableFeature(BABYLON.WebXRAnchorSystem.Name, "latest");
        
                let lastHit = null;
                let activeWrapper = null;
                let activePivot = null;
                const speed = 0.0025, deadzone = 0.06, MODEL_SCALE = 0.02;
        
                hitTest.onHitTestResultObservable.add((results) => {
                    if (results && results.length) {
                        lastHit = results[0];
                        marker.isVisible = true;
                        lastHit.transformationMatrix.decompose(marker.scaling, marker.rotationQuaternion, marker.position);
                    } else {
                        marker.isVisible = false;
                        lastHit = null;
                    }
                });
        
                async function createWrapperAtHit() {
                    if (!container || !lastHit) return;
                    const inst = container.instantiateModelsToScene(n => "blue_crab_" + Date.now() + "_" + n, false);
                    const wrapper = new BABYLON.TransformNode("modelRoot_" + Date.now(), scene);
                    inst.rootNodes.forEach(n => n.setParent(wrapper));
                    wrapper.rotationQuaternion = new BABYLON.Quaternion();
                    wrapper.scaling.setAll(MODEL_SCALE);
                    if (anchors) {
                        const pivot = new BABYLON.TransformNode("anchorPivot_" + Date.now(), scene);
                        const anchor = await anchors.addAnchorPointUsingHitTestResultAsync(lastHit);
                        anchor.attachedNode = pivot;
                        wrapper.parent = pivot;
                        activePivot = pivot;
                    } else {
                        const s = new BABYLON.Vector3(), r = new BABYLON.Quaternion(), t = new BABYLON.Vector3();
                        lastHit.transformationMatrix.decompose(s, r, t);
                        wrapper.rotationQuaternion.copyFrom(r);
                        wrapper.position.copyFrom(t);
                    }
                    activeWrapper = wrapper;
                }
        
                async function moveWrapperToHit() {
                    if (!activeWrapper || !lastHit) return;
                    if (anchors) {
                        const newPivot = new BABYLON.TransformNode("anchorPivot_" + Date.now(), scene);
                        const anchor = await anchors.addAnchorPointUsingHitTestResultAsync(lastHit);
                        anchor.attachedNode = newPivot;
                        activeWrapper.parent = newPivot;
                        if (activePivot) activePivot.dispose();
                        activePivot = newPivot;
                    } else {
                        const s = new BABYLON.Vector3(), r = new BABYLON.Quaternion(), t = new BABYLON.Vector3();
                        lastHit.transformationMatrix.decompose(s, r, t);
                        activeWrapper.rotationQuaternion.copyFrom(r);
                        activeWrapper.setAbsolutePosition(t);
                    }
                }
        
                async function onTrigger() {
                    if (!activeWrapper) await createWrapperAtHit();
                    else await moveWrapperToHit();
                }
        
                xr.input.onControllerAddedObservable.add((xrController) => {
                    if (xrController.inputSource.handedness !== "right") return;
                    xrController.onMotionControllerInitObservable.add((mc) => {
                        const trigger = mc.getComponentOfType("trigger");
                        if (trigger) {
                            trigger.onButtonStateChangedObservable.add(() => {
                                if (trigger.pressed && xr.baseExperience.state === BABYLON.WebXRState.IN_XR) onTrigger();
                            });
                        }
                        const stick = mc.getComponentOfType("xr-standard-thumbstick");
                        scene.onBeforeRenderObservable.add(() => {
                            if (!activeWrapper) return;
                            let ax = 0, ay = 0;
                            if (stick && stick.axes) { ax = stick.axes.x || 0; ay = stick.axes.y || 0; }
                            else if (xrController.inputSource && xrController.inputSource.gamepad && xrController.inputSource.gamepad.axes) {
                                const a = xrController.inputSource.gamepad.axes; ax = (a[0] || 0); ay = (a[1] || 0);
                            }
                            if (Math.abs(ax) < deadzone) ax = 0;
                            if (Math.abs(ay) < deadzone) ay = 0;
                            if (ax === 0 && ay === 0) return;
                            const dt = engine.getDeltaTime();
                            const p = activeWrapper.getAbsolutePosition().clone();
                            p.x += ax * speed * dt;
                            p.z += ay * speed * dt;
                            activeWrapper.setAbsolutePosition(p);
                        });
                    });
                });
            });
        
            return scene;
        };
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
