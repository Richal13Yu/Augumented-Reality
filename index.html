<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // Playground 版:Q3 WebXR + 命中测试放置 + 摇杆平移(加载 Assets 面板的 blue_crab.glb)
// 使用说明:先把 blue_crab.glb 拖到 Playground 的 Assets 面板,再运行本代码

var createScene = async function () {
  const scene = new BABYLON.Scene(engine);

  // 桌面调试相机/光:进入 AR 后 XR 相机接管
  scene.createDefaultCameraOrLight(true, true, true);
  scene.createDefaultEnvironment({ createGround: false, environmentTexture: false });

  // HUD
  const hud = document.createElement("div");
  hud.style.cssText = "position:fixed;left:8px;top:8px;z-index:99;background:#000a;color:#fff;padding:8px 10px;border-radius:10px;font:12px/1.4 system-ui";
  hud.innerHTML = "Q3 WebXR:对准平面 → 轻触/右手扳机放置;右手摇杆在水平面移动。需 HTTPS 与 AR 设备支持。";
  document.body.appendChild(hud);

  // 启动 WebXR (immersive-ar)
  const xr = await scene.createDefaultXRExperienceAsync({
    uiOptions: { sessionMode: "immersive-ar" },
    optionalFeatures: true,
  });

  // 启用 Hit Test
  const fm = xr.baseExperience.featuresManager;
  const hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
    entityTypes: ["plane", "mesh"],
    offsetRay: new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 1), 20),
  });

  let lastHitPose = null;
  hitTest.onHitTestResultObservable.add((results) => {
    if (results && results.length) {
      lastHitPose = results[0].transformationMatrix.clone(); // world matrix
    }
  });

  // --- 加载模型 ---
  // 方案 A(推荐):从 Playground 的 Assets 面板加载本地文件
  const ROOT = "./";        // 指向 Assets 面板
  const FILE = "blue_crab.glb"; // 你拖进去的文件名

  // 如果想用远程 URL(需 CORS 允许),把下面两行替换为:
  // const ROOT = "";
  // const FILE = "https://your.cdn.com/path/blue_crab.glb";

  let originalRoot = null;
  try {
    const { meshes } = await BABYLON.SceneLoader.ImportMeshAsync("", ROOT, FILE, scene);
    originalRoot = meshes.find(m => !m.parent) || meshes[0];
    meshes.forEach(m => m.setEnabled(false)); // 隐藏原始层级,放置时再克隆启用

    // 自动缩放到 ~0.35m 包围盒
    const bb0 = originalRoot.getHierarchyBoundingVectors();
    const size = bb0.max.subtract(bb0.min);
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = maxDim > 0 ? 0.35 / maxDim : 1.0;
    originalRoot.scaling.scaleInPlace(scale);

    // 如需朝向修正(例如绕 X 轴 -90°):originalRoot.rotation.x = -Math.PI / 2;

    originalRoot.computeWorldMatrix(true);
    hud.innerHTML += "<br/>模型加载完成。";
  } catch (e) {
    hud.innerHTML += "<br/>模型加载失败,请确认已把 blue_crab.glb 拖到 Assets 面板。";
    console.error(e);
  }

  let placedRoot = null;
  function placeAtHit() {
    if (!originalRoot || !lastHitPose) return;

    if (!placedRoot) {
      placedRoot = originalRoot.clone("placedRoot");
      placedRoot.getChildMeshes(true).forEach(m => m.setEnabled(true));
    }

    placedRoot.setEnabled(true);
    placedRoot.setPreTransformMatrix(lastHitPose);

    // 让模型“落地”:按包围盒 minY 修正高度
    const bb = placedRoot.getHierarchyBoundingVectors(true);
    const minY = bb.min.y;
    if (isFinite(minY)) {
      placedRoot.position.y -= minY;
    }

    placedRoot.computeWorldMatrix(true);
  }

  // 无手柄:AR 轻触/点击放置
  xr.baseExperience.sessionManager.onSelectObservable.add(() => placeAtHit());

  // 右手手柄:扳机放置,摇杆平移
  xr.input.onControllerAddedObservable.add((xrController) => {
    if (xrController.inputSource.handedness !== "right") return;

    xrController.onMotionControllerInitObservable.add((mc) => {
      // 扳机 → 放置
      const trigger = mc.getComponentOfType("trigger");
      trigger.onButtonStateChangedObservable.add(() => {
        if (trigger.pressed) placeAtHit();
      });

      // 摇杆 → 水平平移
      const stick = mc.getComponentOfType("xr-standard-thumbstick");
      const speed = 0.0025; // 每毫秒的移动系数
      scene.onBeforeRenderObservable.add(() => {
        if (!placedRoot || !stick || !stick.axes) return;
        const dx = stick.axes.x || 0;   // 左(-)/右(+)
        const dy = stick.axes.y || 0;   // 前(+)/后(-)
        if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) return;

        const dt = engine.getDeltaTime();
        const pos = placedRoot.getAbsolutePosition().clone();
        pos.x += dx * speed * dt;
        pos.z += dy * speed * dt;
        placedRoot.setAbsolutePosition(pos);
      });
    });
  });

  return scene;
};
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>

